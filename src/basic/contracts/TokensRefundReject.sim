contract TokensRefundReject {
    data {
        Id string
    }
    func closeNotes() {
        var notes array
        notes = DBFind("@1notifications").Where({"ecosystem": $ecosystem_id, "page_name": "@1voting_view", "page_params->voting_id": $votingID})
        var i int
        while i < Len(notes){
            var note map
            note = notes[i]
            var noteId int
            noteId = Int(note["id"])
            @1NotificationsClose("notific_id", noteId)
            i = i + 1
        }
    }

    conditions {
        var prevContract string
        prevContract = $stack[0]
        if Len($stack) > 2 {
            prevContract = $stack[Len($stack) - 2]
        }
        if prevContract != "@1VotingDecisionCheck"{
            warning LangRes("@1contract_start_votingdecisioncheck_only", "en")
        }
        
        $Id = Int($Id)
        $tokenrefund = DBFind("tokens_refund").Where({"id": $Id}).Row()
        if !$tokenrefund{
            warning LangRes("@1tokens_refund_not_found", "en")
        }

        $victimAddress = $tokenrefund["victim_address"]
        $attackerAddress = $tokenrefund["attacker_address"]
        $amount = Money($tokenrefund["amount"])
        $votingID = Int($tokenrefund["voting_id"])
    }

    action {
        closeNotes()

        // status - 0. Accounts blocked, 1. Discussion, 2. Vote, 3. Closed
        // result - 0. Discussion and voting, 1. Cancelled, 2. Tokens returned
        if $tokenrefund["result"] == 1 || $tokenrefund["result"] == 2 || $tokenrefund["status"] == 3 {
            return
        }
        
        TokensLockoutMember("Address,Value", $victimAddress, 0)
        TokensLockoutMember("Address,Value", $attackerAddress, 0)

        DBUpdate("tokens_refund", $Id, {status:3, result:1})
    }
}