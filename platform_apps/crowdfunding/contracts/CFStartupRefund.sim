contract CFStartupRefund {
    data {
        Id int
    }
    func checkPrevContract(contracts array) {
        var i lenContracts int prev string
        prev = $stack[0]
        if Len($stack) > 2 {
            prev = $stack[Len($stack) - 2]
        }
        lenContracts = Len(contracts)
        while i < lenContracts {
            if prev == contracts[i]{
                return
            }
            i = i + 1
        }
        warning "The validation error of the previous contract in the stack"
    }
    conditions{
        checkPrevContract(["@1CFStartupStatusUpdate", "@1CFAdmin"])

        $CREATED = 1
        $PUBLISHED = 2
        $STARTED = 3
        $FINISHED = 4
        $FAILED = 5
        $STOPPED = 6
        $REJECTED = 7

        $startup = DBFind("@1cf_startups").Where({id:$Id, status:$FINISHED, deleted_at:0}).Row()
        if !$startup{
            warning "Startup with finished status not found"
        }
        var appId admin int feeWallet string
        appId = Int(DBFind("@1applications").Where({ecosystem:1, name:"Crowdfunding"}).One("id"))
        admin = Int(AppParam(appId, "cf_catalog_admin", 1))
        if !RoleAccess(admin){
            var ecoAdmin eco int
            eco = Int($startup["ecosystem"])
            ecoAdmin = Int(DBFind("@1parameters").Where({name:"role_admin", ecosystem:eco}).One("value"))

            if !DBFind("@1roles_participants").Where({"role->id":ecoAdmin, "member->member_id": $key_id, ecosystem:eco, deleted:0}).Row(){
                if $startup["wallet"] != IdToAddress($key_id){
                    warning "You must be Admin in target ecosystem or owner of wallet investments"
                }
            }else{
                warning "This action allowed only for startup catalog admin role"
            }
        }
        var currentAmount estimatedAmount money
        currentAmount = Money($startup["current_investment"])
        estimatedAmount = Money($startup["estimated_amount"])

        if currentAmount >= estimatedAmount {
            warning "Can not refund tokens"
        }
    }
    func refund(){
        var items array i lenItems limit int it map recipient sender int
        sender = AddressToId($startup["wallet"])
        limit = 10000
        items = DBFind("@1cf_investments").Where({startup_id: $Id, refund_at:0}).Limit(limit)
        lenItems = Len(items)
        while i < lenItems{
            it = items[i]
            recipient = AddressToId(it["investment_wallet"])
            @1TokensTransfer("Amount,SenderId,RecipientId,Comment", Money(it["amount"]), sender, recipient, "startup investment refund")
            DBUpdate("@1cf_investments", Int(it["id"]), {refund_at:$block_time})
            i = i + 1
        }
        if lenItems == limit{
            refund()
        }
    }
    action {
        refund()
        // TODO: оповестить владельца стартапа
    }
}